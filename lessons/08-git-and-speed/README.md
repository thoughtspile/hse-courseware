# Занятие 07.03.17

Коротко и по проекту:
> Чтобы превратить репозиторий на гитхабе в сайт с адресом
> `<имя пользвателя>.github.io/<имя проекта>`
> Нужно пушнуть в гитхаб ветку `gh-pages` с нужными файлами.

Всё остальное — для тех, кому эти слова ни о чем не говорят.

## Git

Гит — система конторля версий, написанная специально для разработки Линукса.
Общая идея системы контроля версий: хранить несколько версий файлов, созданных
в разные моменты. Профит:
- Всегда есть копия старой версии, и можно не бояться навсегда сломать программу.
Не-программисты для этого копируют папочку.
- Просто создать резервную копию данных. Не-программисты используют яндекс-диск
или флешку.
- Список версий — очень краткая история изменений. Не нужно читать код, чтобы
узнать, что изменилось.

В гите одно сохраненное состояние называется **коммит**.
Все коммиты текущего проекта — **репозиторий**.

Уметь работать с гитом через консоль очень полезно: вы сможете пользоваться им
на любом сервере (сервера обычно работают на линуксе, и гит установлен там по
умолчанию). В любом случае, полезно представлять, что происходит внутри.

### Не очень практичные факты про гит

Не очень практичный факт: каждая гит-команда (`git remote ...`, `git add ...`,
`git push ...`) на самом деле является отдельной программой:
`git remote` — программа `git-remote`. Это отличный пример unix-философии:
много маленьких утилит, которые работают вместе, а не большая монолитная система.

Каждый коммит в гите хранит *полную* копию данных. Если выкинуть или потерять
часть коммитов, одна копия всё равно сохранится. Другие системы контроля версий
(например, SVN) хранят только дифф — отличие от предыдущей версии.

Все рабочие файлы гита хранятся в скрытой папке `.git`

### Как добавить коммит (закоммитить)

```sh
git add . # Добавить в следующий коммит все файлы в текущей папке (текущая папка = `.`)
git commit -m "add a commit" # Создать коммит с сообщением (текст в кавычках)
```

В сообщении к коммиту коротко пишут, что изменилось с прошлого раза. По
сообщениям просто различать коммиты.

### Ветки (branches)

Для каждого проекта полезно иметь несколько версий одновременно. Например,
в разных ветках можно разрабатывать независимые функции, а в основной (обычно
это ветка master) — иметь стабильную версию. Ветка в гите — просто список ссылок
на коммиты.

Профит:
- Всегда можно подготовить рабочую сборку проекта (из стабильной ветки).
- Разные люди могут работать над разными функциями в отдельных ветках и не
мешать друг другу.
- Перед тем, как добавить функцию из отдельной ветки в мастер, можно:
  - Протестировать её. Когда ветку отвели, всё работало, потому что master —
  стабильный, а никаких изменений, кроме разработки функции, в ней не произошло.
  - Провести код-ревью, чтобы в проект не попал грязный и непонятный код.
- Можно автоматически собирать проект, когда в мастере появляются новые коммиты.

Процесс разработки, построенный на этих принципах, называют
[git-flow.](http://nvie.com/posts/a-successful-git-branching-model/)

Структуру гит-веток рисуют так:
```
o-o-o-o-o-* master
   \  \
    \  o-o-o-o feature-2
     \
      o-o feature-1
```

Ветку создают командой `git branch <имя ветки>`. Переключаются между разными
ветками команой `git checkout <имя ветки>`.

После того, как разработка в ветке закончена, изменения из неё возвращают в
основную ветку (мёржить):
```sh
git checkout <основная ветка> # менять основную ветку можно только работая в ней
git merge <ветка с новым кодом> # вставить измененный код
```

Если какая-то строка поменялась в обеих ветках, которые мержат, происходит конфликт.
В таком случае нужно смотреть на обе версии и выбирать нужный вариант. Мержить
лучше не в консоли, а на гитхабе (битбакете, гитлабе) — там можно в интерфейсике
посмотреть все изменения в коде, провести код-ревью, и к тому же остается артефакт —
запись о том, кто, когда, что и куда вмержил.

Особый гит-шик — перед мержем отребейзить ветку на мастер. Ребейз работает так:
У ветки есть base — коммит мастера, от которого ее отвели. Допустим, что с тех
пор в мастере появились новые коммиты.
```
o-o-o master
 \
  o-o feature
```
Мастер-версия работает. feature тоже работает, но может сломаться от новых
изменений мастера. `git rebase master` работает так:
1. Убираем из feature все коммиты.
2. Заменяем base на текущее состояние мастера
3. Применяем коммиты из feature по одному обратно. Если возникают конфликты, разрешаем их сразу.
Получается так:
```
o-o-o master
     \
      o-o feature
```
Теперь можно спокойно протестировать feature с новейшей версией проекта и вмержить
без конфликтов.

### Удаленные репозитории (remotes)

Каждая копия гит-репозитория хранит список адресов своих удаленных копий.
Например, если вы используете гитхаб, то скорее всего у вас есть удаленная копия
`origin` по адресу `git@githib.com:<имя пользователя>/<название проекта на гитхабе>`.

У проекта может быть много локальных версий на разных компьютерах и несколько
копий на разных серверах — например, на гитхабе и на корпоративном. У копий
может быть разное состояние веток — они же не постоянно обновляют друг друга.

Текущую версию ветки в удаленном репозитории *стягивают* `git pull <имя ремоута> <имя ветки>`.
Например, `git pull origin master`.

Локальную версию в удаленный репозиторий *пушат*: `git push origin master`

Вывести список всех ремоутов с адресами:
```sh
git remote -v # -v = verbose, многословный. По умолчанию команда выводит только имена.
```

### Как захостить сайт на гитхабе

Пушнуть в гитхаб ветку `gh-pages`. Все файлы в этой ветке станут доступны по
адресу `<имя пользвателя>.github.io/<имя проекта>/<путь к файлу>`. Например, этот
файл можно скачать по адресу [https://thoughtspile.github.io/hse-courseware/lessons/08-git-and-speed/README.md]()

Кодом:
```sh
git branch gh-pages # если ветки еще нет
git push origin gh-pages
```

Важно *не работать* в ветке `gh-pages`, а делать все изменения в мастере и только
потом обновлять:
```sh
git checkout gh-pages # чтобы работать с веткой gh-pages, нужно в нее перейти
git rebase master # обновить ветку gh-pages до master
git push -f origin gh-pages # обновить ветку на гитхабе, -f игнорирует конфликты
git checkout master # вернуться в рабочую ветку
```
По вкусу обновлять можно через `git merge master` или `git reset --hard master`
(вообще `reset --hard` очень опасный, но тут вполне к месту).

Возможно, после этого сайт все равно не обновится — значит, он закеширован у вас
в браузере. Попробуйте посмотреть в режиме инкогнито или открыть консоль и отключить
кеширование.
