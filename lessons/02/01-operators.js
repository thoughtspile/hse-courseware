// Операторы на числах работают как обычно (степени нет)
console.log(7 * 23 + (125 - 3) / 2);

// На булях тоже
console.log(true && false, true || false); // false true

// `+` для строк конкатенирует
console.log('hello' + ' my friends'); // 'hello my friends'

// ** Приведение типов **

// Оператор +, приводит типы аргументов, чтобы операция все еще имела смысл.
console.log('str' + 123); // число 123 стало строкой '123'
console.log('str' + false); // false стал строкой 'false'
console.log(0 + true); // true стал числом 1

// Логические операторы не обязательно возвращают булево значение
// || возвращает левый аргумент, если он приводится к булевому true...
console.log(12 || 0); // 12
// ... иначе -- правый
console.log(0 || 84); // 84
// дальше по ассоциативности
console.log(0 || false || 'hello'); // то же, что (0 || fasle) || 'hello' или false || 'hello'

// Значение, которое приводится к false, называют falsy. Вот все фолси-значения:
// false, 0, NaN, '' (пустая строка), null и undefined
// Остальные значения (в том числе любой объект) -- truthy (например, 1, 'пират', [1,2]).

// && возвращает первый truthy аргумент
console.log(12 && 44, null && 'hello'); // 12 'hello'

// ** js-идиомы с операторами **

console.log('' + 12); // привести к строке
console.log(!!'hello'); // привести к булю
console.log(null || {}); // получить второй аргумент, если первый -- фолси

// Например, эта функция выводит первый элемент массива.
const logFirst = arr => console.log(safeArr[0]);
// Если вместо массива передать undefined, функция не сможет получить элемент по индексу и сломается.
// logFirst();

const logFirstSafe = arr => {
  // Если arr -- falsy, то это точно не массив. Подменим его на пустой массив, чтобы ничего не сломалось.
  const safeArr = arr || [];
  // По индексу 0 в пустом массиве лежит ничего, и выведется undefined, зато программа продолжит работать.
  console.log(arr[0]);
};
logFirstSafe();

// Впрочем, в новых версиях js это можно сделать так:
const sugar = (arr = []) => console.log(arr[0]);
sugar();

// Маленькое отличие -- тут [] подставляется только вместо undeined, а не любого falsy, и это правильно:
const oopsDef = (num) => {
  num = num || 12;
  console.log(num);
};
oopsDef(0); // ой, 12, потому что 0 falsy

const goodDef = (num = 12) => console.log(num);
goodDef(0); // 0
goodDef(); // 12
// так-то лучше!
