const routeFiles = [
  fs.readFileSync(__dirname + '/rawdata/1.json'),
  fs.readFileSync(__dirname + '/rawdata/2.json'),
];
// Сейчас в routeFiles лежат JSON-СТРОКИ, потому что fs.readFile читает файл в виде СТРОКИ
// Каждый файл выглядит примерно так:
// {
//   "number": "16",
//   "type": "TRAM",
//   "ostanovki": [
//     {
//       "id": 1,
//       "name": "лесная",
//       "lat": 55,
//       "lon": 49
//     }, {
//       "id": 2,
//       "name": "полевая",
//       "lat": 56,
//       "lon": 49
//     }
//   ]
// }

// Будем перекладывать данные вот в этот объект.
// Напомню, что результат должен быть ОДНИМ файлом вида
// {
//   // Маршруты
//   "routes": {
//     "<route_uid>": {
//       "id": "<номер или название маршрута>",
//       "trips": {
//         // Разные варианты маршрута: например, А->B и B->A. Они часто различаются.
//         // Если вариант один, все равно записать так.
//         "<trip_uid>": {
//           "stops": [ "<stop_id_0>", ... ],
//           // Трассировка маршрута между остановками, если доступна.
//           // Если таких данных нет, просто переложить кооринаты остановок
//           "shape": [
//             {
//               "lat": <широта>,
//               "lon": <долгота>
//             },
//             ...
//           ]
//         }
//       }
//     },
//     ...
//   },
//   "stops": {
//     "<stop_id>": {
//       "lat": <широта>,
//       "lon": <долгота>,
//       "title": "<название>"
//     },
//     ...
//   }
// }
const result = {
  routes: {},
  stops: {},
};

// Для каждого входного файла с данными попробуем переложить данные в result в нужном формате
routeFiles.forEach(routeStr => {
  // НИКОГДА не работаем с JSON как со строкой, ВСЕГДА сначала преобразуем в js-объект:
  const route = JSON.parse(routeStr);
  // Остановки нужно переложить в result.stops
  route.ostanovki.forEach(stop => {
    // result.stops - объект, в котором каждая остановка встречается один раз.
    // Ключ в result.stops - уникальный id, по которому result.routes ссылается на свои остановки
    // Название остановки не подходит для ключа, потому что у разных остановок часто совпадают названия
    //   (например, куча разных остановок у метро называется "Станция метро такая-то")
    // Оператор [] адресует поле объекта по ключу
    // Кстати, в js запись object.key - просто сахар для object['key'].
    //   Скобки [] обязательно использовать в двух случаях:
    //   - ключ - переменная (наш случай: obj[i] не то же, что obj.i)
    //   - ключ - не валидный идентификатор (не мог бы быть имененм переменной, например, object['12-*gg'])
    result.stops[stop.id] = {
      lat: stop.lat,
      lon: stop.lon,
      title: stop.name,
    };
  });
  // Трюк: номер маршрута не всегда уникален: могут быть трамвай и троллейбус с
  // одинаковым номером, но в разных местах.
  // Соберем уникальный id маршрута из двух частей:сида транспорта и номера
  const routeId = route.number + ':' + route.type;
  // То же, что чуть выше
  result.routes[routeId] = {
    id: route.number,
    trips: {
      // просто название для единственного варианта маршрута.
      // Нет, я не считаю это хорошим названием.
      // Если в ваших данных у остановок есть поле direction - оно указывает на направление,
      // сделайте в trips два поля и запишите в каждое только нужные остановки.
      vpered: {
        // Из каждой остановки-объекта вытаскиваем id, по которому она хранится в result.stops
        stops: route.ostanovki.map(stop => stop.id),
        // Из каждой остановки-объекта вытаскиваем координаты.
        // Если в ваших данных есть трассировка (shape, track, или другое поле с кучей координат)
        //   то нужно взять ее, а не координаты остановок -
        //   Соединять остановки отрезком сойдет, но на самом деле транспорт идет не так и
        //   строить по таким данным карту (не схему, а с привязкой к географии) не имеет смысла.
        shape: route.ostanovki.map(stop => {
          return {
            lat: stop.lat,
            lon: stop.lon,
          };
        }),
      }
    },
  };
});
// Только после того, как ОБЪЕКТ с данными готов, делаем из него JSON-СТРОКУ:
const resJson = JSON.stringify(result, null, '  ')
// и записваем полученную СТРОКУ в файл
fs.writeFileSync('data.json', resJson);
